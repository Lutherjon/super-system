小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：**oo***oooo

如果同时翻转左边的两个硬币，则变为：oooo***oooo

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

输入格式
两行等长的字符串，分别表示初始状态和要达到的目标状态。

输出格式
一个整数，表示最小操作步数

数据范围
输入字符串的长度均不超过100。
数据保证答案一定有解。

输入样例1：
**********
o****o****
输出样例1：
5
输入样例2：
*o**o***o***
*o***o**o***
输出样例2：
1

#include<iostream>
using namespace std;
string a,b;
int main()
{
    cin>>a>>b;
    int ans=0;
    for(int i=0;i<a.size()-1;i++)
    if(a[i]!=b[i])//是必须翻转两枚，但是不用在代码里面实现，不需要后续遍历，所以感觉就如果遇到不同的了翻转后一枚硬币就可以了
    {
        ans++;
            if(a[i+1]=='*')
            a[i+1]='o';
            else
            a[i+1]='*';
    }
    cout<<ans<<endl;
}

作者：带着点诗意走吧
链接：https://www.acwing.com/activity/content/code/content/4740239/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
